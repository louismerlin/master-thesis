%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EPFL report package, main thesis file
% Goal: provide formatting for theses and project reports
% Author: Mathias Payer <mathias.payer@epfl.ch>
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,11pt,oneside]{report}
% Options: MScThesis, BScThesis, MScProject, BScProject
\usepackage[MScThesis,lablogo]{EPFLreport}
\usepackage{xspace}
\usepackage{listings}
% Enable all todo comments.
\usepackage[]{todonotes}
% Uncomment this to disable the comment blocks
% \usepackage[disable]{todonotes} 
% This is how we do comments for papers in the lab. This way you can see it 
% both in TeX and when you compile the PDF. Make sure they're all removed for 
% the final version by switching the lines above. I also don't mind if you 
% delete them once resolved because I can see them changed in git :)
\newcommand{\ant}[1]{\todo[inline,color=blue!40]{Antony: #1}}
\newcommand{\dam}[1]{\todo[inline,color=red!40]{Damian: #1}}
\newcommand{\lou}[1]{\todo[inline,color=green!40]{Louis: #1}}

\lstset{ 
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  frame=single,	                   % adds a frame around the code
  language=C++,                    % the language of the code
}

\title{Recovering type information from compiled binaries\\to aid in instrumentation}
\author{Louis Merlin}
\supervisor{Antony Vennard}
\adviser{Prof. Dr. sc. ETH Mathias Payer}
%\coadviser{Second Adviser}
\expert{Damian Pfammatter}

\newcommand{\sysname}{FooSystem\xspace}

\setlength{\parindent}{0cm}

\begin{document}
\maketitle
\makededication
\makeacks

\begin{abstract}
The abstract serves as an executive summary of your project.
Your abstract should cover at least the following topics, 1-2 sentences for
each: what area you are in, the problem you focus on, why existing work is
insufficient, what the high-level intuition of your work is, maybe a neat
design or implementation decision, and key results of your evaluation.
\end{abstract}

% \begin{frenchabstract}
% For a doctoral thesis, you have to provide a French translation of the
% English abstract. For other projects this is optional.
% \end{frenchabstract}

\maketoc

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%

% The introduction is a longer writeup that gently eases the reader into your
% thesis~\cite{dinesh20oakland}. Use the first paragraph to discuss the setting.
% In the second paragraph you can introduce the main challenge that you see.
% The third paragraph lists why related work is insufficient.
% The fourth and fifth paragraphs discuss your approach and why it is needed.
% The sixth paragraph will introduce your thesis statement. Think how you can
% distill the essence of your thesis into a single sentence.
% The seventh paragraph will highlight some of your results
% The eights paragraph discusses your core contribution.

% This section is usually 3-5 pages.


% Setting: compiled binaries; RetroWrite; [need for a compatible exchange format => DWARF;] closed-source C++ binaries in the wild (android?).

Work on C++ began in 1979, as a "C with classes"~\cite{cwithclasses}.
Since then, the language has grown in popularity, and even surpassed C itself~\cite{stackoverflowpopularity}.
Examples of well-known C++ projects include modern browsers like Chrome~\cite{chrome} and Firefox~\cite{firefox}, the Qt Framework~\cite{qt}, or the zoom~\cite{zoom} conferencing software.
Nevertheless, reverse-engineering efforts have been focused towards C binaries, because analysis methods found this way will often work on C++ binaries too.


% Main challenge:
% C++-specific ELF sections are not as well documented as they could be (?);
% Debuggers do not work as well as they should on non-C binaries;

This has meant reverse engineering tools like ghidra~\cite{ghidra}, IDA Pro~\cite{ida} or Binary Ninja~\cite{binja} have treated non-C binaries as second-class citizen.
These tools will often show C++ specific features as passing comments, failing to show the real implications of a try/catch block or a polymorphic class.

% Ghidra/IDA will show as pseudo-C code, but not C++
%  see throw/catch or RTTI
% C++ is quite a compilicated language.
% C's abstractions work very well in assembler, but C++ adds a whole layer of complexity.
% When translated to assembly, a lot of information is lost.

The blame can mostly be put on the complexity of C++ when compared to C.
Whereas C translates quite naturally to assembly, abstractions specific to C++ require more work and complexity to be translated to asm.
This also leads to important information being lost from C++ source code to binary, but also certain information remaining.


% Related work:
% RetroWrite only does C;
% debugging tools don't have nice support for C++ features;
% DWARF will be explored more and more in the coming years;

The recent RetroWrite~\cite{dinesh20oakland} project by the HexHive lab is a static rewriting tool for x86\_64 position-independent binaries.
It enables the instrumentation of projects when we do not have access to the source code.
This can include a legacy project, a closed-source product or even malware.

% Does anything else try to do retrowriting C++ ?
% Does anything else try to extract classes ? (Marx / plugins)


% Our approach:
% Tool for static analysis of C++ binaries, to recover classes and display them in a helpful way;
% Fixing RetroWrite to support C++ binaries;

In this thesis we would like to present the \textbf{dis-cover}~\cite{discovergithub} static analysis tool,
as well as improvements made to RetroWrite to support C++ binaries.


% Why it is needed:
% Non-obtrusive way of adding C++ support in debugging tools;
% Nobody (?) (as far as we know / to the best of our knowledge) has been able to rewrite C++ binaries before, this could lead to very interesting discoveries;

The dis-cover tool is able to extract information from a C++ binary, and re-inject it as debug information using the DWARF format into the binary.
This enables other debugging tools to see and display this information.


% Highlight results:
% 53\% of packages on Debian that use C++ have extracteable classes;
% [whatever we are able to do with C++ and RetroWrite];


% It's a first symbolic representation of C++ code that can be recompiled


% Core contribution:
% dis-cover as an open-source tool;
% [whatever we are able to add to RetroWrite];
% Also the documentation of the process.

[IF WE SUCCEEDED]
In this thesis we would like to show how we brought C++ support to RetroWrite, and what research opportunities this will create.

[IF WE FAILED]
In this thesis we will detail how we tried to bring C++ support to RetroWrite, and what remains to be done for the implementation to work.


%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%%%%%

% The background section introduces the necessary background to understand your
% work. This is not necessarily related work but technologies and dependencies
% that must be resolved to understand your design and implementation.

% This section is usually 3-5 pages.

\section{C++ and polymorphism}

% C++ polymorphism (what, how, but also research like Marx) (+ exceptions) 
% also talk about how compilers will optimize this out in certain situtations
The C++ programming language implements polymorphism.
This feature enables complex code logic that can comply with external business logic for example.
\ant{Yes - I would expand on this a bit. 
The key part is that C++ allows the programmer to create abstract concepts in the 
language itself. One example is an interface, which C++ calls an abstract base 
class - this lets different programmers in different teams only need to know 
what interface to implement for their objects and not need to care so much 
about the underlying detail. The key is that this is also enforced and checked 
by the compiler, as opposed to C where you can do this but you need to 
document it, so it should be more efficient for programmers.

You can also re-use functionality by inheriting parent classes, meaning that if 
you want to implement a Dog and your Animal class already has an implementation 
for Eat, you don't need a dog-specific implementation if appropriate. 

Sometimes we can make all of these decisions at compile time, but polymorphsm 
requires that we use dynamic dispatch, as we can't always know what instance 
of a class will be supplied.

I know we haven't actually covered this as much as we could have but... C++ is 
nice but also horrible :)
}
Polymorphic classes are defined by having at least one virtual method, which is inheritable and overridable.
With this polymorphism comes type conversion, and more interestingly for us the \textbf{dynamic\_cast}~\cite{dynamiccast} expression.
Dynamic casting is a safe kind of type conversion.
It only will successfully cast if the value is of the referenced type or a base type of that type.
In order to achieve that, the system must have some kind of information about the object's data type at run time.
\ant{So let's tidy this up a little bit. I probably don't explain it very well 
except when I write. dynamic\_cast allows you to downcast: you can convert a 
base or more abstract type to a more concrete type. So if you have:
A : B : C
where A is the base, then you can dynamic cast an A to a B or C, if it really 
is a C in the first place.
Upcasting is what happens when we become more abstract, so go from C to A. 
This should work with just a plain old static\_cast.}

This is where Run-Time Type Information (\textbf{RTTI}) comes into the picture.
The system will use this RTTI to infer type inheritance for dynamic casting.
We will now go into implementation details of RTTIs and VTables, which point to them.

To make RTTIs appear in your C++ binary, you will to define classes that inherit from each other, as well as at least one virtual method in one of these classes.
\autoref{classes} shows an example of such classes.

\begin{figure}[h]
\begin{lstlisting}
class Animal {
public:
  virtual void speak() {}
};

class Dog {
public:
  virtual void speak() { cout << "Woof" << endl; }
}
\end{lstlisting}
\caption{Polymorphic classes in C++}
\label{classes}

\end{figure}

For RTTIs to appear in your C++ binary, you will also need to instantiate these classes, and have some run time logic to make the binary non-deterministic [this not the right word I think, I mean to say that the binary depends on some input for its class-instantiating logic].
For example, a conditional dynamic cast between the two classes we defined in \autoref{classes}.
If you do not do these things, the class logic will be abstracted away by the compiler for optimization reasons.

\begin{figure}[h]

\includegraphics[width=16cm]{RTTI_graph.png}
\caption{Overview of an example of VTables and RTTI in memory}
\label{rttigraph}

\end{figure}

The structure of VTables and RTTIs is detailed in \autoref{rttigraph}.
All of this is defined in the Itanium C++ ABI~\cite{cppabi}.
An instance of a virtual class Animal will contain the \textbf{vtblptrAnimal}, a pointer to the virtual table (\textbf{VTable}) for the Animal class.
This VTable will contain pointers to the virtual methods of the class, which are inherited and thus do not have to be duplicated for each class, they are simply pointed to.
The first value preceding the VTable is a pointer to the RTTI of the class. The process finds out the class inheritance of a class instance by following this pointer.

The RTTI itself is composed of an offset (used for complex class inheritance structures) as well as a pointer to the type name (this type name is not removed by simple stripping of the binary, like with \textbf{objdcopy --strip-all}).
This name is mangled using C++ mangling, and can trivially be demangled. This name is what we use to uniquely identify a class in a project (and make sure we have no duplicates).
\lou{Talk about why there is mangling (ELF documentation should have the answer) and a basic example of how it works and why it can be useful (overloading for example).}
The next values of the RTTI are pointers to the RTTIs of the parent classes. See \autoref{rttigraph} for an example, with the Dog RTTI containing a pointer to the Animal RTTI.

\section{ELF format}

\lou{ELF sections}
\ant{Exceptions and how they work :)}
\lou{Relocation tables}
\lou{PIE}


\section{DWARF debugging standard}

\ant{MOAR!! :) There is quite a bit you can say here. DWARF powers debuggers, 
and lets you do things like map source to binary code, recover variable 
names, function names that might not be external symbols, as well as class 
information.
Another key point to mention for later will be the structure of how it is used 
in EH\_Frame. DWARF uses an abstract representation of the processor, so its 
register 1 for example must be mapped to the processor.}
\lou{Regarding Antony's comment => more info about the justification for using DWARF.
Also, the EH\_FRAME is also used for going back on the stack for debugging purposes.}
\lou{Talk about the Compile Unit}
% DWARF DIEs
\textbf{DWARF} is the debugging standard used widely in conjunction with executable ELF files.
It is often included in these ELF files in the \textbf{.debug\_info} section (and other related sections).
This debug information is made up of Debugging Information Entries (\textbf{DIEs}).
These entries can contain information about variable names, method definitions, the compilation process, or more importantly for us, class names and class inheritance.


\section{RetroWrite}

% How RetroWrite works
\ant{So here you can cite the Retrowrite paper and reword some of what they 
say in your own words. Especially: about what we mean by symbolization in assembly, 
why we avoid heuristics for the moment (to be sure it works, also because shared 
libraries are usually always PIE so we have something to target).
You can also talk about the compilation process here, as GCC will emit 
its intermediate assembly. Then the assembler and linker resolve the symbols 
that are required.}
\lou{Also, what are we trying to achieve ? Why are we integrating into RetroWrite ?
Also, mention Cffix (one of HexHive's publications), and how RetroWrite could implement this}

%%%%%%%%%%%%%%%%
\chapter{Design}
%%%%%%%%%%%%%%%%

% Introduce and discuss the design decisions that you made during this project.
% Highlight why individual decisions are important and/or necessary. Discuss
% how the design fits together.

% This section is usually 5-10 pages.

% Design => Decisions
% We decided not to reproduce Marx's work
% First attempt : recover classes from RTTI
% Future work : could take approaches like Marx and re-feed it like us
Class recovery from compiled C++ binaries has been tried multiple ways before:
there are plugins for popular debugging tools, like ida\_gcc\_rtti~\cite{idagccrtti} for IDA Pro,
or Ghidra-Cpp-Class-Analyzer~\cite{ghidracppclassanalyzer} for Ghidra;
there are academic projects such as MARX~\cite{marx} that rely on heuristics around VTables to find classes and inheritance information.
The MARX project can recover classes when no RTTI is present (in the Chrome project for example, where the \textbf{fno-rrti} compilation flag is used), but not with 100\% accuracy.
\lou{IDA : you need the license; Ghidra : not usable outside of ghidra; MARX : different (and cite accuracy statistics)}

% VTable => RTTI
%   mention class data (Debian analysis)
For this project we decided to focus on RTTIs which, as mentioned in the Background chapter, are available for a class hierarchy tree when there is at least one virtual method implemented by one of the classes.
\lou{Why did we decide to focus on RTTIs ? We wanted to be able to get information from C++ binaries, make it available through DWARF and use that information in RetroWrite for a proof of concept.
More complex analysis projects could use the same process in the future.}
We decided to test if RTTIs occurred often in the wild : we proceed to download every Debian package that listed C++ as a dependency (get the list with \textbf{apt-cache rdepends libgcc1} on a Debian machine).
Out of around 80'000 packages, 5827 of them list C++ as a dependency.
Out of those, we extracted classes from 3194 (54\%).
\lou{Maybe talk about the fact that the other 46\% might have classes, but they are optimized aways in many cases.}
We will share more details about this experiment in the Evaluation chapter.

% Also: exceptions (we felt this needed to be handled)
Exceptions are often implemented as classes, and our tool will naturally recover information about programmer-defined exceptions.
Future extension of this work might consider reconvering more information about exceptions.
We also considered extracting information about exceptions, which is another big feature that differentiates C++ from C. \lou{Remove / Rephrase this sentence}
We decided not to focus on this feature, as it did not seem to bring as much to the project considering the evaluated development time.
We did have to study and work with exceptions and exception handling frames for the augmentation of RetroWrite (see the end of the Implementation chapter).

% Why do we want DWARF data ?
%   We want to make the info available to reversing tools
%   => input from Dr. Sergey Bratus
%        He would like to see DWARF used as a lingua franca for debugging
% Also, exception's try/catch blocks & exception types
% but dwarf is limited for this (=> future work)
Next comes the question : what should we do with all of this information ? What would be the most useful format to output the data in ?
This is where DWARF~\cite{dwarf} comes in the picture. DWARF is the debugging standard for programs.
It is mostly used by developers trying to understand where their implementation fails,
and by reverse engineers to get a better understanding of how a program was conceived (although DWARF information is usually stripped from proprietary software).
This kind of debug data is mostly found in C and C++ projects. % Should I add another language ?
By having DWARF data as an output, the information would become readable by most modern reversing tools.

There is a current push for DWARF to become the lingua franca for reverse engineering tools, lead by researchers like Dr. Sergey Bratus~\cite{bratus} from DARPA.
He has published a paper in 2011 where he was able to exploit certain features of DWARF to control program execution : Exploiting the hard-working DWARF~\cite{hardworkingdwarf}.
\lou{Talk more about the hard-working DWARF : talk about what DWARF allows and what it gives you (turing complete ?)
Also: why is it becoming the lingua franca ? Why does it matter ?}

% Injecting debug section & symbols
With dis-cover, we are able to inject information in the debug and symbol sections of the binary, creating a new ELF file with all of this useful info included.
We will go more into the implementation details in the next chapter.

% RetroWrite structure
%  x86_64 userspace and kernel, and arm_64
%  We've decided to focus on the x86_64 userspace
%    Most widely used target
%    Kernel drivers are mostly written in C
% We still want to keep the deterministic ability of retrowrite
Another focus of this project was the augmentation of RetroWrite for C++ capabilities.
Today, RetroWrite supports the reversing of x86\_64 position-independent binaries.
There was also work to augment RetroWrite to support kernel code~\cite{rwkernel} and arm\_64~\cite{rwarm}.
We aimed to add C++ capabilities for x86\_64 binaries only, as it is the most widly used platform (though the same logic will most probably apply with a little tweaking to ARM and other achitectures).
\lou{Mention the fact that we're trying to enable the usage of the dis-cover data in RetroWrite and other RE tools.}

Another potential use of the class information is to implement defenses around type confusion, working with the findings from the HexType~\cite{hextype} paper.
We decided not to focus on this for our project, as it would have been out of the scope of a 6-months master thesis.
\lou{Not "out of the scope" but "we hope that future people will be able to do it".}

One of the defining properties of RetroWrite is that it does not use heuristics (and thus does not have probabilistic features and failures).
Dis-cover has the same no-heuristics property, and thus could be used by the RetroWrite project without breaking the property.
\lou{(to make retrowrite more generic, we will need heuristics, but that is for future people => we might accept analysis like MARX in the future)}


%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%

% The implementation covers some of the implementation details of your project.
% This is not intended to be a low level description of every line of code that
% you wrote but covers the implementation aspects of the projects.

% This section is usually 3-5 pages.

% Python script (because RetroWrite; and good tools) (1 sentence)
We decided to write a python module for this project, as the python ecosystem has great reverse engineering packages, and for easy integration in RetroWrite, which is also written in python.

\section{Finding RTTIs}

% RTTI and VTable
The first thing dis-cover does is find ELF sections where the VTables and RTTIs could be hiding.
This is usually \textbf{.rodata} (read-only data), but could sometimes also be related sections like \textbf{.data.rel.ro}, \textbf{.data.rel.ro.local}, or \textbf{.rdata}.
As per the Itanium C++ ABI, the base VTable of a class will contain an "offset-to-top", which will be 0 in the primary base virtual table's case, followed by a pointer to an RTTI.
We simply have to pattern-match for zeroes directly followed by a pointer to another part of the read-only data sections, and we have a potential RTTI pointer.

\lou{Explain the "primary base virtual table" and why it's the one we're interested in.}
\lou{This could be diagramed (RTTIs) => multiple inheritance, diamond problem...}

To check whether we have found an RTTI, we assert that the next value is a pointer to a string located in a read-only data section.
If it is, we can extract it, demangle it, and we have a class and a name.
The next values in the RTTI are pointers to the RTTIs the class inherits from.
We can go through them and parse them if we have not already, to add this inheritance information to the original class.

This algorithm is $O(n)$, as adding a class only adds one more value to parse.

\section{Creating DWARF data}

% Creating DIEs
Next, we want to add that information to the debug sections of a new ELF file.

% DIE Bytecode
In order to write DWARF data, the first step is defining the types we will be using, and their fields.
This is done by writing bytes in the \textbf{.debug\_abbrev} section.
For example, we create an abbrev of type \textbf{class\_type}, which has a \textbf{name}, and can have sub-field (children).
Then, we create the abbrev of type \textbf{inheritance}, which has a \textbf{type} (a reference to the parent type).

We can then populate the \textbf{.debug\_info} with classes and their inheritance data.
DWARF data takes the form of a tree of values. We have to create a \textbf{compile\_unit} value at the root, and then the branches will be \textbf{class\_type}s.
These \textbf{class\_type}s will themselves have as children \textbf{inheritance} values if the class inherits from another class.
\autoref{dwarfdump} shows a very simple example of this, with two class types and one inheriting from the other.

\begin{figure}[h]
\begin{lstlisting}
< 1><0x0000001a>    DW_TAG_class_type
                      DW_AT_containing_type       <0x0000001a>
                      DW_AT_calling_convention    DW_CC_pass_by_reference
                      DW_AT_name                  Shape
                      DW_AT_byte_size             0x00000008
< 1><0x00000026>    DW_TAG_class_type
                      DW_AT_containing_type       <0x00000026>
                      DW_AT_calling_convention    DW_CC_pass_by_reference
                      DW_AT_name                  Rectangle
                      DW_AT_byte_size             0x00000008
< 2><0x00000031>      DW_TAG_inheritance
                        DW_AT_type                  <0x0000001a>
\end{lstlisting}
\caption{Extract of a dwarfdump output showing simple inheritance}
\label{dwarfdump}
\end{figure}

The strings themselves are stored in another section, \textbf{.debug\_str}, and are referred to with their offset in that section.

\lou{The three dwarf sections should be explained in more detail in the Background or Design sections.}

\section{Creating symbols}

% symbols
Symbols are used to have access to variable names, class names, function names or any other kind of text information when debugging a binary.
\lou{Symbols are also used for shared object loading}
We want to create two symbols for every class we have found during the analysis : one pointing to the VTable and one pointing to the RTTI, labeling them as such.

In order to create new symbol sections, we take the symbol table from the original binary (if there was one) and append the aforementioned symbols.

The two symbol sections are \textbf{.symtab}, which contains the information (offset, size, type, ...) for each symbol, and \textbf{.strtab}, which contains the strings related to these symbols.

\section{Wrapping things together}

\subsection{Creating a fake ELF file}

% eu-unstrip etc
Once we have the three debug sections ready
(\textbf{.debug\_abbrev} with the debug types, \textbf{.debug\_info} with the debug information, and \textbf{debug\_str} with the strings)
as well as the two symbol sections, we have to make them available to the user.
The first step is building an empty ELF file with only these five sections in them.\lou{"we'll discuss why in 4.4.3"}
\lou{say about the three dwarf sections => this is the dwarf information we have recovered, and we are trying to incorporate it into the binary.}

We start by constructing a \textbf{program header table}.
This table contains information about the offset and size of each segment of the binary (which segment is used for what, and their read/write permissions).
The ELF file we're creating will not be run, but only used temporarily.
Thus, we noticed that we did not have to create a valid program header table for the process to work.
We simply copy this program header table almost as-is from the original binary.

Next, we use the individual sections we built earlier and construct the \textbf{section header table}.
For every section present in the original binary, we create an entry in the section header table, reusing most values from the original section header table.
The only values we modify is the offset.
For every section that we have created, we add the appropriate row in the section header table.
Every section name gets added to the \textbf{.shstrtab} section, as per the convention.

Finally, we construct the \textbf{elf header}, taking some of the values from the original binaries, and calculating some others from the size of the tables and sections we have built.
We can now create a fake ELF file by appending the elf header, the program header table, the sections we built and the section header table.

\subsection{Stripping the original ELF file}

Next, we will create a stripped version of the original ELF file.
We use the \textbf{objcopy --strip-all} command.
This is to avoid section conflicts in the next step.

\subsection{Combining the two ELF files}

Now, we can use the ELF utility program \textbf{eu-unstrip} to combine the two ELF files we have created into one.
The newly created combined ELF file will contain all of the code and data from the original file, as well as the debug and symbol sections we have created.
\lou{Talk about why we had to do all of that, and the fact that DWARF info rarely comes alone.
eu-unstrip lets us merge the 2 different elf files, but they have to closely match, which is why we're going though these steps.}

% what it does and does not do

% RetroWrite implementation details
% Refer to the other thesis

% unwind tables etc

%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}
%%%%%%%%%%%%%%%%%%%%

% In the evaluation you convince the reader that your design works as intended.
% Describe the evaluation setup, the designed experiments, and how the
% experiments showcase the individual points you want to prove.

% This section is usually 5-10 pages.

\section{Small case studies}

% Small examples
In addition to the first version of dis-cover, we created three small programs highlighting different features of C++.
One was using simple inheritance,
one had a namespace (which we can and should recover as part of the analysis),
and the last one was a use case of multiple inheritance (using the diamond problem).

We also created a script that would compile these 3 programs using different levels of compiler optimization.
We could then use dis-cover to see if we could recover every class and the correct tree from the binaries.
This served as a useful benchmark to check whether dis-cover was functioning correctly if we tried to apply changes to it.

These examples alone were not capable of letting us evaluate the full capabilities of dis-cover.
We found a few big applications that could serve that purpose.

\section{Big case studies}

% Big applications examples
The first and smallest of these case studies was the \textbf{gold linker}~\cite{gold}.
We were able to find 571 classes in version 1.16 of the program.
This provides a good benchmark, but the classes themselves do not make use of multiple inheritance (only a "simple" inheritance tree).

\textbf{LibreOffice}~\cite{libreoffice} on the other hand provided us with a great test case :
the program is fragmented into many small libraries, containing some interesting uses of multiple inheritance.
See \autoref{libloglo} for an example of multiple inheritance in the \textbf{libloglo.so} library from LibreOffice.
This particular example was very important for verifying a big bug that was present in an early version of dis-cover.
After fixing the bug, we were noticing around 10\% more inheritance links in some projects (but not more classes).
Being able to go check with the open-source LibreOffice code that we had found the right inheritance links was extremely helpful.

\begin{figure}[h]

\includegraphics[width=16cm]{libloglo_partial.png}
\caption{Partial class tree of libloglo.so from LibreOffice}
\label{libloglo}

\end{figure}

Finally, we also were able to study the closed-source \textbf{zoom}~\cite{zoom} binary.
This test case is very interesting in two ways.
First, we are able to find \textbf{6039 classes} in the binary, with \textbf{5601 edges} in the class hierarchy graph.
Second, as a large (76M) and complex ELF file, it served as a perfect benchmark for the performance of the algorithm.
By adding a simple check earlier in the RTTI-spotting pipeline, we were able to speed up the analysis of the zoom binary 13.37 times, from over an hour to five minutes.

\autoref{discoverbenchmarks} details the benchmarks we conducted on many well-known projects.

\begin{table}[h]
  \centering
  {\small
  \begin{tabular}{l | r | r | r | r }
    ELF File and version & Size & Size of .rodata & Computation time & Amount of classes recovered  \\
    \hline
    gold 1.16 & 2.3M & 0.1M & 0m0.605s & 571 \\
    ceph-dencoder 15.2.13 & 29M & 0.9M & 0m12.493s & 2959 \\
    zoom 5.5.7938.0228 & 76M & 16M & 5m50.626s & 6039 
  \end{tabular}
  }

\caption{Benchmarks of dis-cover on a machine running Ubuntu 20.04 with a 2.6 Ghz dedicated vCPU}
\label{discoverbenchmarks}

\end{table}

% Debian test
As we have shown before, out of the 5827 Debian packages that list C++ as a dependency, we were able to extract classes from 3194 (54\%).
The total number of classes we found is 960'188, with 39\% of them unique across all packages (unique name in unique tree).

% RetroWrite test


%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related Work}
%%%%%%%%%%%%%%%%%%%%%%

The related work section covers closely related work. Here you can highlight
the related work, how it solved the problem, and why it solved a different
problem. Do not play down the importance of related work, all of these
systems have been published and evaluated! Say what is different and how
you overcome some of the weaknesses of related work by discussing the 
trade-offs. Stay positive!

This section is usually 3-5 pages.

% Marx


%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%

In the conclusion you repeat the main result and finalize the discussion of
your project. Mention the core results and why as well as how your system
advances the status quo.

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\printbibliography

% Appendices are optional
% \appendix
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{How to make a transmogrifier}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% In case you ever need an (optional) appendix.
%
% You need the following items:
% \begin{itemize}
% \item A box
% \item Crayons
% \item A self-aware 5-year old
% \end{itemize}

\end{document}
